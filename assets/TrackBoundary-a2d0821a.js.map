{"version":3,"file":"TrackBoundary-a2d0821a.js","sources":["../../../fake-agora-rtc/src/top.ts","../../../fake-agora-rtc/src/utils.ts","../../../fake-agora-rtc/src/eventemitter.ts","../../../fake-agora-rtc/src/tracks/track.ts","../../../fake-agora-rtc/src/tracks/local-track.ts","../../../fake-agora-rtc/videos/ipad-2988.mp4","../../../fake-agora-rtc/src/tracks/local-video-track.ts","../../../fake-agora-rtc/videos/quick-mechanical-keyboard-14391.mp3","../../../fake-agora-rtc/src/tracks/local-audio-track.ts","../../../fake-agora-rtc/src/tracks/camera-video-track.ts","../../../fake-agora-rtc/src/tracks/microphone-audio-track.ts","../../../fake-agora-rtc/src/index.ts","../../src/utils.ts","../../src/hooks/tools.ts","../../src/components/TrackBoundary.tsx"],"sourcesContent":["import type { IAgoraRTC } from \"agora-rtc-sdk-ng\";\n\nexport function createFakeAgoraRTC(\n  executor?: Partial<IAgoraRTC> | (() => Partial<IAgoraRTC>),\n): IAgoraRTC {\n  const partialRTC = typeof executor === \"function\" ? executor() : executor;\n  return partialRTC as unknown as IAgoraRTC;\n}\n","export function hideProperties<T>(o: T, ...properties: string[]): void {\n  Object.defineProperties(\n    o,\n    [...properties, \"_constructor-name_\"].reduce(\n      (o, k) => ((o[k] = { writable: true, enumerable: false }), o),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      {} as any,\n    ),\n  );\n}\n","import { hideProperties } from \"./utils\";\n\ntype Fn = (...args: any[]) => unknown;\n\n/** Fake Agora internal Eventemitter */\nexport class FakeAgoraEventEmitter {\n  private _events = new Map<string, Fn[]>();\n  private _once = new WeakMap<Fn, Fn>();\n\n  public constructor() {\n    hideProperties(this, \"_events\", \"_once\");\n  }\n\n  /**\n   * Gets all the listeners for a specified event.\n   *\n   * @param event The event name.\n   */\n  public getListeners(event: string): Fn[] {\n    return this._events.get(event) || [];\n  }\n  /**\n   * Listens for a specified event.\n   *\n   * When the specified event happens, the SDK triggers the callback that you pass.\n   * @param event The event name.\n   * @param listener The callback to trigger.\n   */\n  public on(event: string, listener: Fn): void {\n    const listeners = this._events.get(event) || [];\n    if (!listeners.includes(listener)) {\n      listeners.push(listener);\n    }\n    this._events.set(event, listeners);\n  }\n  /**\n   * Listens for a specified event once.\n   *\n   * When the specified event happens, the SDK triggers the callback that you pass and then removes the listener.\n   * @param event The event name.\n   * @param listener The callback to trigger.\n   */\n  public once(event: string, listener: Fn): void {\n    const onceListener = (...args: any[]) => {\n      this.off(event, onceListener);\n      listener(...args);\n    };\n    this._once.set(listener, onceListener);\n    this.on(event, onceListener);\n  }\n  /**\n   * Removes the listener for a specified event.\n   *\n   * @param event The event name.\n   * @param listener The callback that corresponds to the event listener.\n   */\n  public off(event: string, listener: Fn): void {\n    listener = this._once.get(listener) || listener;\n    const listeners = this._events.get(event) || [];\n    const index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n    this._events.set(event, listeners);\n  }\n  /**\n   * Removes all listeners for a specified event.\n   *\n   * @param event The event name. If left empty, all listeners for all events are removed.\n   */\n  public removeAllListeners(event?: string): void {\n    if (event) {\n      this._events.delete(event);\n    } else {\n      this._events.clear();\n    }\n  }\n\n  public dispatch(event: string, ...payload: unknown[]): void {\n    this._events.get(event)?.forEach(listener => listener(...payload));\n  }\n}\n\nexport function dispatchRTCEvent(emitter: unknown, event: string, ...payload: unknown[]): void {\n  if (emitter && (emitter as FakeAgoraEventEmitter).dispatch) {\n    (emitter as FakeAgoraEventEmitter).dispatch(event, ...payload);\n  }\n}\n","import { randUuid } from \"@ngneat/falso\";\nimport type { ITrack } from \"agora-rtc-sdk-ng\";\n\nimport { FakeAgoraEventEmitter } from \"../eventemitter\";\nimport { hideProperties } from \"../utils\";\n\nexport interface FakeTrackProps {\n  trackMediaType?: \"audio\" | \"video\";\n  trackId?: string;\n}\n\nexport class FakeTrack extends FakeAgoraEventEmitter {\n  public static create(props?: FakeTrackProps): ITrack {\n    return new FakeTrack(props) as unknown as ITrack;\n  }\n\n  private readonly _trackId: string;\n\n  protected constructor({ trackMediaType = \"video\", trackId = randUuid() }: FakeTrackProps = {}) {\n    super();\n\n    this.trackMediaType = trackMediaType;\n    this._trackId = trackId;\n\n    hideProperties(this, \"_trackId\");\n  }\n\n  /**\n   * The type of a media track:\n   * - `\"audio\"`: Audio track.\n   * - `\"video\"`: Video track.\n   */\n  public trackMediaType: \"audio\" | \"video\";\n  /**\n   * Whether a media track is playing on the webpage:\n   * - `true`: The media track is playing on the webpage.\n   * - `false`: The media track is not playing on the webpage.\n   */\n  public isPlaying = false;\n  /**\n   * Gets the ID of a media track, a unique identifier generated by the SDK.\n   *\n   * @return The media track ID.\n   */\n  public getTrackId(): string {\n    return this._trackId;\n  }\n  /**\n   * Gets an [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object.\n   *\n   * @return An [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object.\n   */\n  public getMediaStreamTrack(): MediaStreamTrack {\n    throw new Error(\"Method not implemented.\");\n  }\n  /**\n   * Plays a media track on the webpage.\n   *\n   * @param element Specifies a DOM element. The SDK will create a `<video>` element under the specified DOM element to play the video track. You can specify a DOM element in either of following ways:\n   * - `string`: Specify the ID of the DOM element.\n   * - `HTMLElement`: Pass a DOM object.\n   */\n  public play(element?: string | HTMLElement): void {\n    this.isPlaying = true;\n    console.log(\"[FakeTrack]: play\", element);\n  }\n\n  /**\n   * Stops playing the media track.\n   */\n  public stop(): void {\n    this.isPlaying = false;\n  }\n}\n","import { randProductDescription } from \"@ngneat/falso\";\nimport type { ILocalTrack, LocalAudioTrackStats, LocalVideoTrackStats } from \"agora-rtc-sdk-ng\";\n\nimport { hideProperties } from \"../utils\";\n\nimport type { FakeTrackProps } from \"./track\";\nimport { FakeTrack } from \"./track\";\n\nexport interface FakeLocalTrackProps extends FakeTrackProps {\n  /** track label */\n  label?: string;\n  enabled?: boolean;\n  muted?: boolean;\n}\n\nexport class FakeLocalTrack extends FakeTrack {\n  public static override create(props?: FakeLocalTrackProps): ILocalTrack {\n    return new FakeLocalTrack(props) as unknown as ILocalTrack;\n  }\n\n  protected _label: string;\n\n  protected constructor({\n    label = randProductDescription(),\n    enabled = true,\n    muted = false,\n    ...trackProps\n  }: FakeLocalTrackProps = {}) {\n    super(trackProps);\n    this._label = label;\n    this.enabled = enabled;\n    this.muted = muted;\n\n    hideProperties(this, \"_label\");\n  }\n  /**\n   * **Since**\n   * <br>&emsp;&emsp;&emsp;*4.0.0*\n   *\n   * Enables/Disables the track.\n   *\n   * After a track is disabled, the SDK stops playing and publishing the track.\n   *\n   * > - Disabling a track does not trigger the [LocalTrack.on(\"track-ended\")]{@link event_track_ended} event.\n   * > - If a track is published, disabling this track triggers the [user-unpublished]{@link IAgoraRTCClient.event_user_unpublished} event on the remote client, and re-enabling this track triggers the [user-published]{@link IAgoraRTCClient.event_user_published} event.\n   * > - Do not call `setEnabled` and `setMuted` together.\n   *\n   * @param enabled Whether to enable the track:\n   * - `true`: Enable the track.\n   * - `false`: Disable the track.\n   */\n  public async setEnabled(enabled: boolean): Promise<void> {\n    if (enabled !== this.enabled) {\n      this.enabled = enabled;\n      if (enabled) {\n        this.play();\n      } else {\n        this.stop();\n      }\n    }\n  }\n  /**\n   * **DEPRECATED** from v4.1.0. Use [AgoraRTCClient.getLocalVideoStats]{@link IAgoraRTCClient.getLocalVideoStats} and [AgoraRTCClient.getLocalAudioStats]{@link IAgoraRTCClient.getLocalAudioStats} instead.\n   *\n   * Gets the statistics of a local track.\n   *\n   * > Note: When getting the statistics of a local video track, you cannot get the `encodeDelay` property on iOS.\n   */\n  public getStats(): LocalVideoTrackStats | LocalAudioTrackStats {\n    throw new Error(\"Method not implemented.\");\n  }\n  /**\n   * Gets the label of a local track.\n   *\n   * @return The label that the SDK returns may include:\n   * - The [MediaDeviceInfo.label](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo/label) property, if the track is created by calling `createMicrophoneAudioTrack` or `createCameraVideoTrack`.\n   * - The `sourceId` property, if the track is created by calling `createScreenVideoTrack`.\n   * - The [MediaStreamTrack.label](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/label) property, if the track is created by calling `createCustomAudioTrack` or `createCustomVideoTrack`.\n   */\n  public getTrackLabel(): string {\n    return this._label;\n  }\n  /**\n   * Sends or stops sending the media data of the track.\n   *\n   * **Since**\n   * <br>&emsp;&emsp;&emsp;*4.6.0*\n   *\n   * If the track is published, a successful call of `setMuted(true)` triggers the [user-unpublished]{@link IAgoraRTCClient.event_user_unpublished} event on the remote client, and a successful call of `setMuted(false)` triggers the [user-published]{@link IAgoraRTCClient.event_user_published} event.\n   *\n   * > - Calling `setMuted(true)` does not stop capturing audio or video and takes shorter time to take effect than [[setEnabled]]. For details, see [What are the differences between setEnabled and setMuted?](https://docs.agora.io/en/Interactive%20Broadcast/faq/differences_between_setenabled_and_setmuted).\n   * > - Do not call `setEnabled` and `setMuted` together.\n   *\n   * @param muted Whether to stop sending the media data of the track:\n   * - `true`: Stop sending the media data of the track.\n   * - `false`: Resume sending the media data of the track.\n   */\n  public async setMuted(muted: boolean): Promise<void> {\n    this.muted = muted;\n  }\n  /**\n   * Closes a local track and releases the audio and video resources that it occupies.\n   *\n   * Once you close a local track, you can no longer reuse it.\n   */\n  public close(): void {\n    this.stop();\n  }\n\n  public muted: boolean;\n\n  public enabled: boolean;\n}\n","export default \"__VITE_ASSET__090f2396__\"","import type { ILocalVideoTrack, VideoPlayerConfig } from \"agora-rtc-sdk-ng\";\n\nimport ipadMp4 from \"../../videos/ipad-2988.mp4\";\nimport { hideProperties } from \"../utils\";\n\nimport type { FakeLocalTrackProps } from \"./local-track\";\nimport { FakeLocalTrack } from \"./local-track\";\n\nexport interface FakeLocalVideoTrackProps extends Omit<FakeLocalTrackProps, \"trackMediaType\"> {\n  videoURI?: string;\n}\n\nexport class FakeLocalVideoTrack extends FakeLocalTrack {\n  public static override create(props?: FakeLocalVideoTrackProps): ILocalVideoTrack {\n    return new FakeLocalVideoTrack(props) as unknown as ILocalVideoTrack;\n  }\n\n  private readonly _videoURI: string;\n\n  protected constructor({ videoURI = ipadMp4, ...props }: FakeLocalVideoTrackProps = {}) {\n    super({ ...props, trackMediaType: \"video\" });\n\n    this._videoURI = videoURI;\n\n    hideProperties(this, \"_config\", \"_videoEl\", \"_videoURI\");\n  }\n  /**\n   * Plays a local video track on the web page.\n   *\n   * @param element Specifies a DOM element. The SDK will create a `<video>` element under the specified DOM element to play the video track. You can specify a DOM element in either of the following ways:\n   * - `string`: Specify the ID of the DOM element.\n   * - `HTMLElement`: Pass a DOM object.\n   * @param config Sets the playback configurations, such as display mode and mirror mode. See [[VideoPlayerConfig]]. By default, the SDK enables mirror mode for a local video track.\n   */\n  public override play(element: string | HTMLElement, config?: VideoPlayerConfig): void {\n    this._config = config;\n\n    const container = typeof element === \"string\" ? document.getElementById(element) : element;\n\n    if (!this._videoEl) {\n      this._videoEl = document.createElement(\"video\");\n      this._videoEl.style.width = \"100%\";\n      this._videoEl.style.height = \"100%\";\n      this._videoEl.loop = true;\n      this._videoEl.muted = true;\n    }\n\n    this._videoEl.src = this._videoURI;\n    this._videoEl.style.objectFit = this._config?.fit || \"cover\";\n    this._videoEl.style.opacity = \"1\";\n\n    if (container) {\n      while (container.firstChild) {\n        container.removeChild(container.firstChild);\n      }\n      container.appendChild(this._videoEl);\n    }\n\n    if (this.enabled && this._videoEl) {\n      this.isPlaying = true;\n      this._videoEl.play().catch(console.log);\n    }\n  }\n  /**\n   * Stops playing the media track.\n   */\n  public override stop(): void {\n    if (this.isPlaying && this._videoEl) {\n      this.isPlaying = false;\n      this._videoEl.style.opacity = \"0\";\n      this._videoEl.pause();\n    }\n  }\n\n  protected _config?: VideoPlayerConfig;\n  protected _videoEl?: HTMLVideoElement;\n}\n","export default \"__VITE_ASSET__98740572__\"","import type { ILocalAudioTrack } from \"agora-rtc-sdk-ng\";\n\nimport keyboardMp3 from \"../../videos/quick-mechanical-keyboard-14391.mp3\";\nimport { hideProperties } from \"../utils\";\n\nimport type { FakeLocalTrackProps } from \"./local-track\";\nimport { FakeLocalTrack } from \"./local-track\";\n\nexport interface FakeLocalAudioTrackProps extends Omit<FakeLocalTrackProps, \"trackMediaType\"> {\n  audioURI?: string;\n  /** 0~100 */\n  volume?: number;\n}\n\nexport class FakeLocalAudioTrack extends FakeLocalTrack {\n  public static override create(props?: FakeLocalAudioTrackProps): ILocalAudioTrack {\n    return new FakeLocalAudioTrack(props) as unknown as ILocalAudioTrack;\n  }\n\n  private readonly _audioURI: string;\n\n  protected constructor({\n    audioURI = keyboardMp3,\n    volume = 100,\n    ...props\n  }: FakeLocalAudioTrackProps = {}) {\n    super({ ...props, trackMediaType: \"audio\" });\n    this._volume = Math.max(0, Math.min(100, volume));\n    this._audioURI = audioURI;\n\n    hideProperties(this, \"_audioEl\", \"_volume\", \"_audioURI\");\n  }\n  /**\n   * Plays a local audio track on the web page.\n   *\n   * @param element Specifies a DOM element. The SDK will create a `<audio>` element under the specified DOM element to play the audio track. You can specify a DOM element in either of the following ways:\n   * - `string`: Specify the ID of the DOM element.\n   * - `HTMLElement`: Pass a DOM object.\n   * @param config Sets the playback configurations, such as display mode and mirror mode. See [[AudioPlayerConfig]]. By default, the SDK enables mirror mode for a local audio track.\n   */\n  public override play(): void {\n    if (!this._audioEl) {\n      this._audioEl = document.createElement(\"audio\");\n      this._audioEl.loop = true;\n      document.body.appendChild(this._audioEl);\n    }\n\n    this._audioEl.src = this._audioURI;\n    this._audioEl.muted = this.muted;\n    this._audioEl.volume = this._volume / 100;\n\n    if (this.enabled && this._audioEl) {\n      this.isPlaying = true;\n      this._audioEl.play().catch(console.log);\n    }\n  }\n  /**\n   * Stops playing the media track.\n   */\n  public override stop(): void {\n    if (this.isPlaying && this._audioEl) {\n      this.isPlaying = false;\n      this._audioEl.pause();\n    }\n  }\n  /**\n   * Sends or stops sending the media data of the track.\n   *\n   * **Since**\n   * <br>&emsp;&emsp;&emsp;*4.6.0*\n   *\n   * If the track is published, a successful call of `setMuted(true)` triggers the [user-unpublished]{@link IAgoraRTCClient.event_user_unpublished} event on the remote client, and a successful call of `setMuted(false)` triggers the [user-published]{@link IAgoraRTCClient.event_user_published} event.\n   *\n   * > - Calling `setMuted(true)` does not stop capturing audio or audio and takes shorter time to take effect than [[setEnabled]]. For details, see [What are the differences between setEnabled and setMuted?](https://docs.agora.io/en/Interactive%20Broadcast/faq/differences_between_setenabled_and_setmuted).\n   * > - Do not call `setEnabled` and `setMuted` together.\n   *\n   * @param muted Whether to stop sending the media data of the track:\n   * - `true`: Stop sending the media data of the track.\n   * - `false`: Resume sending the media data of the track.\n   */\n  public override async setMuted(muted: boolean): Promise<void> {\n    super.setMuted(muted);\n    if (this._audioEl) {\n      this._audioEl.muted = muted;\n    }\n  }\n  /**\n   * Sets the volume of a local audio track.\n   *\n   * @param volume The volume. The value ranges from 0 (mute) to 1000 (maximum). A value of 100 is the original volume。 The volume change may not be obvious to human ear. If local track has been published, setting volume will affect the volume heard by remote users.\n   */\n  public setVolume(volume: number): void {\n    volume = Math.max(0, Math.min(100, volume));\n    if (this._volume !== volume) {\n      this._volume = volume;\n      if (this._audioEl) {\n        this._audioEl.volume = volume / 100;\n      }\n    }\n  }\n  /**\n   * Gets the audio level of a local audio track.\n   *\n   * @returns The audio level. The value range is [0,1]. 1 is the highest audio level.\n   * Usually a user with audio level above 0.6 is a speaking user.\n   *\n   */\n  public getVolumeLevel(): number {\n    return this._volume / 100;\n  }\n  /**\n   * **Since**\n   * <br>&emsp;&emsp;&emsp;*4.1.0*\n   *\n   * > Note:\n   * > - As of v4.7.0, this method no longer takes effect. Use IRemoteAudioTrack.setPlaybackDevice() instead.\n   * > - This method supports Chrome on desktop devices only. Other browsers throw a '`NOT_SUPPORTED` error when calling this method.\n   *\n   * Sets the playback device (speaker) for the remote audio stream.\n   *\n   * @param deviceId The device ID, which can be retrieved by calling [[getPlaybackDevices]].\n   */\n  public async setPlaybackDevice(deviceId: string): Promise<void> {\n    console.log(\"[FakeLocalAudioTrack]: setPlaybackDevice\", deviceId);\n  }\n\n  private _audioEl?: HTMLAudioElement;\n  private _volume: number;\n}\n","import type { ICameraVideoTrack } from \"agora-rtc-sdk-ng\";\n\nimport type { FakeLocalVideoTrackProps } from \"./local-video-track\";\nimport { FakeLocalVideoTrack } from \"./local-video-track\";\n\nexport interface FakeCameraVideoTrackProps extends FakeLocalVideoTrackProps {}\n\nexport class FakeCameraVideoTrack extends FakeLocalVideoTrack {\n  public static override create(props?: FakeCameraVideoTrackProps): ICameraVideoTrack {\n    return new FakeCameraVideoTrack(props) as unknown as ICameraVideoTrack;\n  }\n  /**\n   * Sets the device for capturing video.\n   *\n   * > You can call this method either before or after publishing the video track.\n   *\n   * @param deviceId The ID of the specified device. You can get the `deviceId` by calling AgoraRTC.getCameras().\n   */\n  public async setDevice(deviceId: string): Promise<void> {\n    console.log(\"[FakeCameraVideoTrack]: setDevice\", deviceId);\n  }\n}\n","import type { IMicrophoneAudioTrack } from \"agora-rtc-sdk-ng\";\n\nimport type { FakeLocalAudioTrackProps } from \"./local-audio-track\";\nimport { FakeLocalAudioTrack } from \"./local-audio-track\";\n\nexport interface FakeMicrophoneAudioTrackProps extends FakeLocalAudioTrackProps {}\n\nexport class FakeMicrophoneAudioTrack extends FakeLocalAudioTrack {\n  public static override create(props?: FakeMicrophoneAudioTrackProps): IMicrophoneAudioTrack {\n    return new FakeMicrophoneAudioTrack(props) as unknown as IMicrophoneAudioTrack;\n  }\n  /**\n   * Sets the device for sampling audio.\n   *\n   * > You can call the method either before or after publishing an audio track.\n   *\n   * @param deviceId The ID of the specified device. You can get the `deviceId` by calling AgoraRTC.getMicrophones().\n   */\n  public async setDevice(deviceId: string): Promise<void> {\n    console.log(\"[FakeMicrophoneAudioTrack]: setDevice\", deviceId);\n  }\n}\n","import { createFakeAgoraRTC } from \"./top\";\nimport { FakeCameraVideoTrack, FakeMicrophoneAudioTrack } from \"./tracks\";\n\nexport * from \"./tracks\";\nexport * from \"./eventemitter\";\nexport * from \"./client\";\n\nexport default createFakeAgoraRTC({\n  createMicrophoneAudioTrack: async () => FakeMicrophoneAudioTrack.create(),\n  createCameraVideoTrack: async () => FakeCameraVideoTrack.create(),\n});\n","export type Disposer = () => void;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Fn = (...args: any[]) => any;\nexport type Nullable<T> = T | null | undefined;\nexport type MaybePromise<T> = T | PromiseLike<T>;\nexport type MaybePromiseOrNull<T> = MaybePromise<Nullable<T>>;\n\nexport function invoke<T>(fn: () => T): T | void {\n  try {\n    return fn();\n  } catch (e) {\n    console.error(e);\n  }\n}\n\nexport function joinDisposers(disposers: Disposer[]): Disposer {\n  return () => disposers.forEach(invoke);\n}\n\nexport function interval(fn: Fn, interval: number): Disposer {\n  const id = setInterval(fn, interval);\n  return () => clearInterval(id);\n}\n\nexport function timeout(fn: Fn, ms: number): Disposer {\n  const id = setTimeout(fn, ms);\n  return () => clearTimeout(id);\n}\n\nexport interface AsyncTaskRunner {\n  run: (this: void, task: () => MaybePromise<void | (() => MaybePromise<void>)>) => void;\n  dispose: (this: void) => void;\n}\n\n/**\n * Chain async tasks. During the task running/stopping, if multiple tasks are triggered, only the last one will be executed.\n */\nexport function createAsyncTaskRunner(): AsyncTaskRunner {\n  let isRunning: boolean | undefined;\n  let nextTask: undefined | (() => MaybePromise<void>);\n  let disposer: undefined | void | (() => MaybePromise<void>);\n\n  function runNextTask() {\n    if (nextTask) {\n      const _nextTask = nextTask;\n      nextTask = void 0;\n      _nextTask();\n    }\n  }\n\n  async function disposeEffect() {\n    if (disposer) {\n      const _disposer = disposer;\n      disposer = void 0;\n      try {\n        await _disposer();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n\n  async function runTask(effect: () => MaybePromise<void | (() => MaybePromise<void>)>) {\n    isRunning = true;\n\n    await disposeEffect();\n\n    try {\n      disposer = await effect();\n    } catch (e) {\n      console.error(e);\n    }\n\n    isRunning = false;\n\n    runNextTask();\n  }\n\n  async function stopTask() {\n    isRunning = true;\n\n    await disposeEffect();\n\n    isRunning = false;\n\n    runNextTask();\n  }\n\n  function run(task: () => MaybePromise<void | (() => MaybePromise<void>)>): void {\n    if (isRunning) {\n      nextTask = () => runTask(task);\n    } else {\n      runTask(task);\n    }\n  }\n\n  function dispose(): void {\n    if (isRunning) {\n      nextTask = stopTask;\n    } else {\n      stopTask();\n    }\n  }\n\n  return {\n    run,\n    dispose,\n  };\n}\n","import type { MutableRefObject, Ref, RefObject } from \"react\";\nimport { useCallback, useEffect, useLayoutEffect, useRef, useState } from \"react\";\n\nimport type { AsyncTaskRunner, MaybePromise } from \"../utils\";\nimport { createAsyncTaskRunner } from \"../utils\";\n\nexport const useIsomorphicLayoutEffect =\n  typeof document !== \"undefined\" ? useLayoutEffect : useEffect;\n\nexport function isPromise<T>(value: MaybePromise<T>): value is PromiseLike<T> {\n  return value != null && typeof (value as PromiseLike<T>).then === \"function\";\n}\n\nexport function useForceUpdate() {\n  const [_, forceUpdate] = useState(0);\n  return useCallback(() => forceUpdate(n => (n + 1) | 0), []);\n}\n\nexport function useIsUnmounted(): RefObject<boolean> {\n  const isUnmountRef = useRef(false);\n  useEffect(() => {\n    isUnmountRef.current = false;\n    return () => {\n      isUnmountRef.current = true;\n    };\n  }, []);\n  return isUnmountRef;\n}\n\n/**\n * Leave promise unresolved when the component is unmounted.\n *\n * ```js\n * const sp = useSafePromise()\n * setLoading(true)\n * try {\n *   const result1 = await sp(fetchData1())\n *   const result2 = await sp(fetchData2(result1))\n *   setData(result2)\n * } catch(e) {\n *   setHasError(true)\n * }\n * setLoading(false)\n * ```\n */\nexport function useSafePromise() {\n  const isUnmountRef = useIsUnmounted();\n\n  function safePromise<T, E = unknown>(\n    promise: PromiseLike<T>,\n    onUnmountedError?: (error: E) => void,\n  ) {\n    // the async promise executor is intended\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise<T>(async (resolve, reject) => {\n      try {\n        const result = await promise;\n        if (!isUnmountRef.current) {\n          resolve(result);\n        }\n        // unresolved promises will be garbage collected.\n      } catch (error) {\n        if (!isUnmountRef.current) {\n          reject(error);\n        } else if (onUnmountedError) {\n          onUnmountedError(error as E);\n        } else {\n          if (process.env.NODE_ENV === \"development\") {\n            console.error(\"An error occurs from a promise after a component is unmounted\", error);\n          }\n        }\n      }\n    });\n  }\n\n  return useCallback(safePromise, [isUnmountRef]);\n}\n\nexport function applyRef<T>(ref: Ref<T>, value: T) {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (typeof ref === \"object\" && ref) {\n    (ref as MutableRefObject<T>).current = value;\n  }\n}\n\n/**\n * Sugar to merge forwarded ref and produce a local ref (state).\n *\n * ```jsx\n * const Button = forwardRef((props, ref) => {\n *   const [div, setDiv] = useForwardRef(ref)\n *   // use 'div' here\n *   return <div ref={setDiv} />\n * })\n * ```\n */\nexport function useForwardRef<T>(ref: Ref<T>): [T | null, (value: T | null) => void] {\n  const [current, setCurrent] = useState<T | null>(null);\n  const forwardedRef = useCallback(\n    (value: T | null) => {\n      setCurrent(value);\n      applyRef(ref, value);\n    },\n    [ref, setCurrent],\n  );\n  return [current, forwardedRef];\n}\n\n/**\n * Await a promise or return the value directly.\n */\nexport function useAwaited<T>(promise: MaybePromise<T>): T | undefined {\n  const sp = useSafePromise();\n  const [value, setValue] = useState<T | undefined>();\n\n  useIsomorphicLayoutEffect(() => {\n    if (isPromise(promise)) {\n      sp(promise).then(setValue);\n    } else {\n      setValue(promise);\n    }\n  }, [promise, sp]);\n\n  return value;\n}\n\n/**\n * Accepts a function that contains imperative, possibly asynchronous effect-ful code.\n * During the side-effect running/removing, if multiple effects are triggered, only the last one will be executed.\n */\nexport function useAsyncEffect(\n  effect: () => MaybePromise<void | (() => MaybePromise<void>)>,\n  deps?: ReadonlyArray<unknown>,\n): void {\n  const runnerRef = useRef<AsyncTaskRunner | undefined>();\n  useEffect(() => {\n    const { run, dispose } = (runnerRef.current ||= createAsyncTaskRunner());\n    run(effect);\n    return dispose;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n","import type {\n  ILocalAudioTrack,\n  ILocalVideoTrack,\n  IRemoteAudioTrack,\n  IRemoteVideoTrack,\n  ITrack,\n} from \"agora-rtc-sdk-ng\";\nimport type { PropsWithChildren } from \"react\";\nimport { createContext, useContext, useEffect, useState } from \"react\";\n\nimport { useIsomorphicLayoutEffect } from \"../hooks/tools\";\nimport type { Nullable } from \"../utils\";\nimport { timeout } from \"../utils\";\n\ninterface TrackBoundaryController {\n  onMount: (track: ITrack) => void;\n  onUnmount: (track: ITrack) => void;\n  dispose: () => void;\n}\n\nfunction createTrackBoundaryController(): TrackBoundaryController {\n  const cancelStops = new Map<ITrack, () => void>();\n  const STOP_TIMEOUT = 1500;\n\n  return {\n    onMount: track => {\n      const cancel = cancelStops.get(track);\n      if (cancel) {\n        cancel();\n        cancelStops.delete(track);\n      }\n    },\n    onUnmount: track => {\n      const cancel = cancelStops.get(track);\n      if (cancel) {\n        cancel();\n      }\n      cancelStops.set(\n        track,\n        timeout(() => {\n          if (track.isPlaying) {\n            track.stop();\n          }\n          cancelStops.delete(track);\n        }, STOP_TIMEOUT),\n      );\n    },\n    dispose: () => {\n      for (const [track, cancel] of cancelStops) {\n        if (track.isPlaying) {\n          track.stop();\n        }\n        if (cancel) {\n          cancel();\n        }\n      }\n      cancelStops.clear();\n    },\n  };\n}\n\nconst TrackBoundaryContext = /* @__PURE__ */ createContext<TrackBoundaryController | undefined>(\n  void 0,\n);\n\n/**\n * Delegates track stop of descendant Track Players.\n * This prevents track stops on Track Players unmounts due to re-layout.\n *\n * @example\n * ```jsx\n * <TrackBoundary>\n *   <RemoteUser user={user1} />\n *   <RemoteUser user={user2} />\n * </TrackBoundary>\n * ```\n *\n * @example\n * ```jsx\n * <TrackBoundary>\n *   <RemoteVideoTrack track={track1} />\n *   <RemoteVideoTrack track={track2} />\n * </TrackBoundary>\n * ```\n */\nexport function TrackBoundary({ children }: PropsWithChildren) {\n  const [controller] = useState(createTrackBoundaryController);\n\n  useEffect(() => controller.dispose, [controller]);\n\n  return (\n    <TrackBoundaryContext.Provider value={controller}>{children}</TrackBoundaryContext.Provider>\n  );\n}\n\n/**\n * Stops local or remote video track when the component unmounts.\n * If `<TrackBoundary />` exists in ancestor it will not stop track on unmount but delegates to TrackBoundary.\n */\nexport function useAutoPlayVideoTrack(\n  track: Nullable<IRemoteVideoTrack | ILocalVideoTrack>,\n  play?: boolean,\n  div?: HTMLElement | null,\n) {\n  const controller = useContext(TrackBoundaryContext);\n\n  useEffect(() => {\n    if (track) {\n      if (div && play) {\n        track.play(div);\n      } else {\n        track.stop();\n      }\n\n      if (controller) {\n        controller.onMount(track);\n        return () => controller.onUnmount(track);\n      } else {\n        return () => {\n          if (track.isPlaying) {\n            track.stop();\n          }\n        };\n      }\n    }\n  }, [track, div, play, controller]);\n}\n\n/**\n * Stops local or remote audio track when the component unmounts.\n * If `<TrackBoundary />` exists in ancestor it will not stop track on unmount but delegates to TrackBoundary.\n */\nexport function useAutoPlayAudioTrack(\n  track: Nullable<IRemoteAudioTrack | ILocalAudioTrack>,\n  play?: boolean,\n) {\n  const controller = useContext(TrackBoundaryContext);\n\n  useIsomorphicLayoutEffect(() => {\n    if (track) {\n      if (play) {\n        track.play();\n      } else {\n        track.stop();\n      }\n\n      if (controller) {\n        controller.onMount(track);\n        return () => controller.onUnmount(track);\n      } else {\n        return () => {\n          if (track.isPlaying) {\n            track.stop();\n          }\n        };\n      }\n    }\n  }, [track, play, controller]);\n}\n"],"names":["createFakeAgoraRTC","executor","hideProperties","o","properties","k","FakeAgoraEventEmitter","__publicField","event","listener","listeners","onceListener","args","index","payload","_a","FakeTrack","trackMediaType","trackId","randUuid","props","element","FakeLocalTrack","label","randProductDescription","enabled","muted","trackProps","ipadMp4","FakeLocalVideoTrack","videoURI","config","container","keyboardMp3","FakeLocalAudioTrack","audioURI","volume","deviceId","FakeCameraVideoTrack","FakeMicrophoneAudioTrack","invoke","fn","e","joinDisposers","disposers","interval","id","timeout","ms","createAsyncTaskRunner","isRunning","nextTask","disposer","runNextTask","_nextTask","disposeEffect","_disposer","runTask","effect","stopTask","run","task","dispose","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","isPromise","value","useIsUnmounted","isUnmountRef","useRef","useSafePromise","safePromise","promise","onUnmountedError","resolve","reject","result","error","useCallback","useAwaited","sp","setValue","useState","createTrackBoundaryController","cancelStops","STOP_TIMEOUT","track","cancel","TrackBoundaryContext","createContext","TrackBoundary","children","controller","useAutoPlayVideoTrack","play","div","useContext","useAutoPlayAudioTrack"],"mappings":"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"}