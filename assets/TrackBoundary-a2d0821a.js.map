{"version":3,"file":"TrackBoundary-a2d0821a.js","sources":["../../../fake-agora-rtc/src/top.ts","../../../fake-agora-rtc/src/utils.ts","../../../fake-agora-rtc/src/eventemitter.ts","../../../fake-agora-rtc/src/tracks/track.ts","../../../fake-agora-rtc/src/tracks/local-track.ts","../../../fake-agora-rtc/videos/ipad-2988.mp4","../../../fake-agora-rtc/src/tracks/local-video-track.ts","../../../fake-agora-rtc/videos/quick-mechanical-keyboard-14391.mp3","../../../fake-agora-rtc/src/tracks/local-audio-track.ts","../../../fake-agora-rtc/src/tracks/camera-video-track.ts","../../../fake-agora-rtc/src/tracks/microphone-audio-track.ts","../../../fake-agora-rtc/src/index.ts","../../src/utils.ts","../../src/hooks/tools.ts","../../src/components/TrackBoundary.tsx"],"sourcesContent":["import type { IAgoraRTC } from \"agora-rtc-sdk-ng\";\n\nexport function createFakeAgoraRTC(\n  executor?: Partial<IAgoraRTC> | (() => Partial<IAgoraRTC>),\n): IAgoraRTC {\n  const partialRTC = typeof executor === \"function\" ? executor() : executor;\n  return partialRTC as unknown as IAgoraRTC;\n}\n","export function hideProperties<T>(o: T, ...properties: string[]): void {\n  Object.defineProperties(\n    o,\n    [...properties, \"_constructor-name_\"].reduce(\n      (o, k) => ((o[k] = { writable: true, enumerable: false }), o),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      {} as any,\n    ),\n  );\n}\n","import { hideProperties } from \"./utils\";\n\ntype Fn = (...args: any[]) => unknown;\n\n/** Fake Agora internal Eventemitter */\nexport class FakeAgoraEventEmitter {\n  private _events = new Map<string, Fn[]>();\n  private _once = new WeakMap<Fn, Fn>();\n\n  public constructor() {\n    hideProperties(this, \"_events\", \"_once\");\n  }\n\n  /**\n   * Gets all the listeners for a specified event.\n   *\n   * @param event The event name.\n   */\n  public getListeners(event: string): Fn[] {\n    return this._events.get(event) || [];\n  }\n  /**\n   * Listens for a specified event.\n   *\n   * When the specified event happens, the SDK triggers the callback that you pass.\n   * @param event The event name.\n   * @param listener The callback to trigger.\n   */\n  public on(event: string, listener: Fn): void {\n    const listeners = this._events.get(event) || [];\n    if (!listeners.includes(listener)) {\n      listeners.push(listener);\n    }\n    this._events.set(event, listeners);\n  }\n  /**\n   * Listens for a specified event once.\n   *\n   * When the specified event happens, the SDK triggers the callback that you pass and then removes the listener.\n   * @param event The event name.\n   * @param listener The callback to trigger.\n   */\n  public once(event: string, listener: Fn): void {\n    const onceListener = (...args: any[]) => {\n      this.off(event, onceListener);\n      listener(...args);\n    };\n    this._once.set(listener, onceListener);\n    this.on(event, onceListener);\n  }\n  /**\n   * Removes the listener for a specified event.\n   *\n   * @param event The event name.\n   * @param listener The callback that corresponds to the event listener.\n   */\n  public off(event: string, listener: Fn): void {\n    listener = this._once.get(listener) || listener;\n    const listeners = this._events.get(event) || [];\n    const index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n    this._events.set(event, listeners);\n  }\n  /**\n   * Removes all listeners for a specified event.\n   *\n   * @param event The event name. If left empty, all listeners for all events are removed.\n   */\n  public removeAllListeners(event?: string): void {\n    if (event) {\n      this._events.delete(event);\n    } else {\n      this._events.clear();\n    }\n  }\n\n  public dispatch(event: string, ...payload: unknown[]): void {\n    this._events.get(event)?.forEach(listener => listener(...payload));\n  }\n}\n\nexport function dispatchRTCEvent(emitter: unknown, event: string, ...payload: unknown[]): void {\n  if (emitter && (emitter as FakeAgoraEventEmitter).dispatch) {\n    (emitter as FakeAgoraEventEmitter).dispatch(event, ...payload);\n  }\n}\n","import { randUuid } from \"@ngneat/falso\";\nimport type { ITrack } from \"agora-rtc-sdk-ng\";\n\nimport { FakeAgoraEventEmitter } from \"../eventemitter\";\nimport { hideProperties } from \"../utils\";\n\nexport interface FakeTrackProps {\n  trackMediaType?: \"audio\" | \"video\";\n  trackId?: string;\n}\n\nexport class FakeTrack extends FakeAgoraEventEmitter {\n  public static create(props?: FakeTrackProps): ITrack {\n    return new FakeTrack(props) as unknown as ITrack;\n  }\n\n  private readonly _trackId: string;\n\n  protected constructor({ trackMediaType = \"video\", trackId = randUuid() }: FakeTrackProps = {}) {\n    super();\n\n    this.trackMediaType = trackMediaType;\n    this._trackId = trackId;\n\n    hideProperties(this, \"_trackId\");\n  }\n\n  /**\n   * The type of a media track:\n   * - `\"audio\"`: Audio track.\n   * - `\"video\"`: Video track.\n   */\n  public trackMediaType: \"audio\" | \"video\";\n  /**\n   * Whether a media track is playing on the webpage:\n   * - `true`: The media track is playing on the webpage.\n   * - `false`: The media track is not playing on the webpage.\n   */\n  public isPlaying = false;\n  /**\n   * Gets the ID of a media track, a unique identifier generated by the SDK.\n   *\n   * @return The media track ID.\n   */\n  public getTrackId(): string {\n    return this._trackId;\n  }\n  /**\n   * Gets an [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object.\n   *\n   * @return An [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) object.\n   */\n  public getMediaStreamTrack(): MediaStreamTrack {\n    throw new Error(\"Method not implemented.\");\n  }\n  /**\n   * Plays a media track on the webpage.\n   *\n   * @param element Specifies a DOM element. The SDK will create a `<video>` element under the specified DOM element to play the video track. You can specify a DOM element in either of following ways:\n   * - `string`: Specify the ID of the DOM element.\n   * - `HTMLElement`: Pass a DOM object.\n   */\n  public play(element?: string | HTMLElement): void {\n    this.isPlaying = true;\n    console.log(\"[FakeTrack]: play\", element);\n  }\n\n  /**\n   * Stops playing the media track.\n   */\n  public stop(): void {\n    this.isPlaying = false;\n  }\n}\n","import { randProductDescription } from \"@ngneat/falso\";\nimport type { ILocalTrack, LocalAudioTrackStats, LocalVideoTrackStats } from \"agora-rtc-sdk-ng\";\n\nimport { hideProperties } from \"../utils\";\n\nimport type { FakeTrackProps } from \"./track\";\nimport { FakeTrack } from \"./track\";\n\nexport interface FakeLocalTrackProps extends FakeTrackProps {\n  /** track label */\n  label?: string;\n  enabled?: boolean;\n  muted?: boolean;\n}\n\nexport class FakeLocalTrack extends FakeTrack {\n  public static override create(props?: FakeLocalTrackProps): ILocalTrack {\n    return new FakeLocalTrack(props) as unknown as ILocalTrack;\n  }\n\n  protected _label: string;\n\n  protected constructor({\n    label = randProductDescription(),\n    enabled = true,\n    muted = false,\n    ...trackProps\n  }: FakeLocalTrackProps = {}) {\n    super(trackProps);\n    this._label = label;\n    this.enabled = enabled;\n    this.muted = muted;\n\n    hideProperties(this, \"_label\");\n  }\n  /**\n   * **Since**\n   * <br>&emsp;&emsp;&emsp;*4.0.0*\n   *\n   * Enables/Disables the track.\n   *\n   * After a track is disabled, the SDK stops playing and publishing the track.\n   *\n   * > - Disabling a track does not trigger the [LocalTrack.on(\"track-ended\")]{@link event_track_ended} event.\n   * > - If a track is published, disabling this track triggers the [user-unpublished]{@link IAgoraRTCClient.event_user_unpublished} event on the remote client, and re-enabling this track triggers the [user-published]{@link IAgoraRTCClient.event_user_published} event.\n   * > - Do not call `setEnabled` and `setMuted` together.\n   *\n   * @param enabled Whether to enable the track:\n   * - `true`: Enable the track.\n   * - `false`: Disable the track.\n   */\n  public async setEnabled(enabled: boolean): Promise<void> {\n    if (enabled !== this.enabled) {\n      this.enabled = enabled;\n      if (enabled) {\n        this.play();\n      } else {\n        this.stop();\n      }\n    }\n  }\n  /**\n   * **DEPRECATED** from v4.1.0. Use [AgoraRTCClient.getLocalVideoStats]{@link IAgoraRTCClient.getLocalVideoStats} and [AgoraRTCClient.getLocalAudioStats]{@link IAgoraRTCClient.getLocalAudioStats} instead.\n   *\n   * Gets the statistics of a local track.\n   *\n   * > Note: When getting the statistics of a local video track, you cannot get the `encodeDelay` property on iOS.\n   */\n  public getStats(): LocalVideoTrackStats | LocalAudioTrackStats {\n    throw new Error(\"Method not implemented.\");\n  }\n  /**\n   * Gets the label of a local track.\n   *\n   * @return The label that the SDK returns may include:\n   * - The [MediaDeviceInfo.label](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo/label) property, if the track is created by calling `createMicrophoneAudioTrack` or `createCameraVideoTrack`.\n   * - The `sourceId` property, if the track is created by calling `createScreenVideoTrack`.\n   * - The [MediaStreamTrack.label](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/label) property, if the track is created by calling `createCustomAudioTrack` or `createCustomVideoTrack`.\n   */\n  public getTrackLabel(): string {\n    return this._label;\n  }\n  /**\n   * Sends or stops sending the media data of the track.\n   *\n   * **Since**\n   * <br>&emsp;&emsp;&emsp;*4.6.0*\n   *\n   * If the track is published, a successful call of `setMuted(true)` triggers the [user-unpublished]{@link IAgoraRTCClient.event_user_unpublished} event on the remote client, and a successful call of `setMuted(false)` triggers the [user-published]{@link IAgoraRTCClient.event_user_published} event.\n   *\n   * > - Calling `setMuted(true)` does not stop capturing audio or video and takes shorter time to take effect than [[setEnabled]]. For details, see [What are the differences between setEnabled and setMuted?](https://docs.agora.io/en/Interactive%20Broadcast/faq/differences_between_setenabled_and_setmuted).\n   * > - Do not call `setEnabled` and `setMuted` together.\n   *\n   * @param muted Whether to stop sending the media data of the track:\n   * - `true`: Stop sending the media data of the track.\n   * - `false`: Resume sending the media data of the track.\n   */\n  public async setMuted(muted: boolean): Promise<void> {\n    this.muted = muted;\n  }\n  /**\n   * Closes a local track and releases the audio and video resources that it occupies.\n   *\n   * Once you close a local track, you can no longer reuse it.\n   */\n  public close(): void {\n    this.stop();\n  }\n\n  public muted: boolean;\n\n  public enabled: boolean;\n}\n","export default \"__VITE_ASSET__090f2396__\"","import type { ILocalVideoTrack, VideoPlayerConfig } from \"agora-rtc-sdk-ng\";\n\nimport ipadMp4 from \"../../videos/ipad-2988.mp4\";\nimport { hideProperties } from \"../utils\";\n\nimport type { FakeLocalTrackProps } from \"./local-track\";\nimport { FakeLocalTrack } from \"./local-track\";\n\nexport interface FakeLocalVideoTrackProps extends Omit<FakeLocalTrackProps, \"trackMediaType\"> {\n  videoURI?: string;\n}\n\nexport class FakeLocalVideoTrack extends FakeLocalTrack {\n  public static override create(props?: FakeLocalVideoTrackProps): ILocalVideoTrack {\n    return new FakeLocalVideoTrack(props) as unknown as ILocalVideoTrack;\n  }\n\n  private readonly _videoURI: string;\n\n  protected constructor({ videoURI = ipadMp4, ...props }: FakeLocalVideoTrackProps = {}) {\n    super({ ...props, trackMediaType: \"video\" });\n\n    this._videoURI = videoURI;\n\n    hideProperties(this, \"_config\", \"_videoEl\", \"_videoURI\");\n  }\n  /**\n   * Plays a local video track on the web page.\n   *\n   * @param element Specifies a DOM element. The SDK will create a `<video>` element under the specified DOM element to play the video track. You can specify a DOM element in either of the following ways:\n   * - `string`: Specify the ID of the DOM element.\n   * - `HTMLElement`: Pass a DOM object.\n   * @param config Sets the playback configurations, such as display mode and mirror mode. See [[VideoPlayerConfig]]. By default, the SDK enables mirror mode for a local video track.\n   */\n  public override play(element: string | HTMLElement, config?: VideoPlayerConfig): void {\n    this._config = config;\n\n    const container = typeof element === \"string\" ? document.getElementById(element) : element;\n\n    if (!this._videoEl) {\n      this._videoEl = document.createElement(\"video\");\n      this._videoEl.style.width = \"100%\";\n      this._videoEl.style.height = \"100%\";\n      this._videoEl.loop = true;\n      this._videoEl.muted = true;\n    }\n\n    this._videoEl.src = this._videoURI;\n    this._videoEl.style.objectFit = this._config?.fit || \"cover\";\n    this._videoEl.style.opacity = \"1\";\n\n    if (container) {\n      while (container.firstChild) {\n        container.removeChild(container.firstChild);\n      }\n      container.appendChild(this._videoEl);\n    }\n\n    if (this.enabled && this._videoEl) {\n      this.isPlaying = true;\n      this._videoEl.play().catch(console.log);\n    }\n  }\n  /**\n   * Stops playing the media track.\n   */\n  public override stop(): void {\n    if (this.isPlaying && this._videoEl) {\n      this.isPlaying = false;\n      this._videoEl.style.opacity = \"0\";\n      this._videoEl.pause();\n    }\n  }\n\n  protected _config?: VideoPlayerConfig;\n  protected _videoEl?: HTMLVideoElement;\n}\n","export default \"__VITE_ASSET__98740572__\"","import type { ILocalAudioTrack } from \"agora-rtc-sdk-ng\";\n\nimport keyboardMp3 from \"../../videos/quick-mechanical-keyboard-14391.mp3\";\nimport { hideProperties } from \"../utils\";\n\nimport type { FakeLocalTrackProps } from \"./local-track\";\nimport { FakeLocalTrack } from \"./local-track\";\n\nexport interface FakeLocalAudioTrackProps extends Omit<FakeLocalTrackProps, \"trackMediaType\"> {\n  audioURI?: string;\n  /** 0~100 */\n  volume?: number;\n}\n\nexport class FakeLocalAudioTrack extends FakeLocalTrack {\n  public static override create(props?: FakeLocalAudioTrackProps): ILocalAudioTrack {\n    return new FakeLocalAudioTrack(props) as unknown as ILocalAudioTrack;\n  }\n\n  private readonly _audioURI: string;\n\n  protected constructor({\n    audioURI = keyboardMp3,\n    volume = 100,\n    ...props\n  }: FakeLocalAudioTrackProps = {}) {\n    super({ ...props, trackMediaType: \"audio\" });\n    this._volume = Math.max(0, Math.min(100, volume));\n    this._audioURI = audioURI;\n\n    hideProperties(this, \"_audioEl\", \"_volume\", \"_audioURI\");\n  }\n  /**\n   * Plays a local audio track on the web page.\n   *\n   * @param element Specifies a DOM element. The SDK will create a `<audio>` element under the specified DOM element to play the audio track. You can specify a DOM element in either of the following ways:\n   * - `string`: Specify the ID of the DOM element.\n   * - `HTMLElement`: Pass a DOM object.\n   * @param config Sets the playback configurations, such as display mode and mirror mode. See [[AudioPlayerConfig]]. By default, the SDK enables mirror mode for a local audio track.\n   */\n  public override play(): void {\n    if (!this._audioEl) {\n      this._audioEl = document.createElement(\"audio\");\n      this._audioEl.loop = true;\n      document.body.appendChild(this._audioEl);\n    }\n\n    this._audioEl.src = this._audioURI;\n    this._audioEl.muted = this.muted;\n    this._audioEl.volume = this._volume / 100;\n\n    if (this.enabled && this._audioEl) {\n      this.isPlaying = true;\n      this._audioEl.play().catch(console.log);\n    }\n  }\n  /**\n   * Stops playing the media track.\n   */\n  public override stop(): void {\n    if (this.isPlaying && this._audioEl) {\n      this.isPlaying = false;\n      this._audioEl.pause();\n    }\n  }\n  /**\n   * Sends or stops sending the media data of the track.\n   *\n   * **Since**\n   * <br>&emsp;&emsp;&emsp;*4.6.0*\n   *\n   * If the track is published, a successful call of `setMuted(true)` triggers the [user-unpublished]{@link IAgoraRTCClient.event_user_unpublished} event on the remote client, and a successful call of `setMuted(false)` triggers the [user-published]{@link IAgoraRTCClient.event_user_published} event.\n   *\n   * > - Calling `setMuted(true)` does not stop capturing audio or audio and takes shorter time to take effect than [[setEnabled]]. For details, see [What are the differences between setEnabled and setMuted?](https://docs.agora.io/en/Interactive%20Broadcast/faq/differences_between_setenabled_and_setmuted).\n   * > - Do not call `setEnabled` and `setMuted` together.\n   *\n   * @param muted Whether to stop sending the media data of the track:\n   * - `true`: Stop sending the media data of the track.\n   * - `false`: Resume sending the media data of the track.\n   */\n  public override async setMuted(muted: boolean): Promise<void> {\n    super.setMuted(muted);\n    if (this._audioEl) {\n      this._audioEl.muted = muted;\n    }\n  }\n  /**\n   * Sets the volume of a local audio track.\n   *\n   * @param volume The volume. The value ranges from 0 (mute) to 1000 (maximum). A value of 100 is the original volumeã€‚ The volume change may not be obvious to human ear. If local track has been published, setting volume will affect the volume heard by remote users.\n   */\n  public setVolume(volume: number): void {\n    volume = Math.max(0, Math.min(100, volume));\n    if (this._volume !== volume) {\n      this._volume = volume;\n      if (this._audioEl) {\n        this._audioEl.volume = volume / 100;\n      }\n    }\n  }\n  /**\n   * Gets the audio level of a local audio track.\n   *\n   * @returns The audio level. The value range is [0,1]. 1 is the highest audio level.\n   * Usually a user with audio level above 0.6 is a speaking user.\n   *\n   */\n  public getVolumeLevel(): number {\n    return this._volume / 100;\n  }\n  /**\n   * **Since**\n   * <br>&emsp;&emsp;&emsp;*4.1.0*\n   *\n   * > Note:\n   * > - As of v4.7.0, this method no longer takes effect. Use IRemoteAudioTrack.setPlaybackDevice() instead.\n   * > - This method supports Chrome on desktop devices only. Other browsers throw a '`NOT_SUPPORTED` error when calling this method.\n   *\n   * Sets the playback device (speaker) for the remote audio stream.\n   *\n   * @param deviceId The device ID, which can be retrieved by calling [[getPlaybackDevices]].\n   */\n  public async setPlaybackDevice(deviceId: string): Promise<void> {\n    console.log(\"[FakeLocalAudioTrack]: setPlaybackDevice\", deviceId);\n  }\n\n  private _audioEl?: HTMLAudioElement;\n  private _volume: number;\n}\n","import type { ICameraVideoTrack } from \"agora-rtc-sdk-ng\";\n\nimport type { FakeLocalVideoTrackProps } from \"./local-video-track\";\nimport { FakeLocalVideoTrack } from \"./local-video-track\";\n\nexport interface FakeCameraVideoTrackProps extends FakeLocalVideoTrackProps {}\n\nexport class FakeCameraVideoTrack extends FakeLocalVideoTrack {\n  public static override create(props?: FakeCameraVideoTrackProps): ICameraVideoTrack {\n    return new FakeCameraVideoTrack(props) as unknown as ICameraVideoTrack;\n  }\n  /**\n   * Sets the device for capturing video.\n   *\n   * > You can call this method either before or after publishing the video track.\n   *\n   * @param deviceId The ID of the specified device. You can get the `deviceId` by calling AgoraRTC.getCameras().\n   */\n  public async setDevice(deviceId: string): Promise<void> {\n    console.log(\"[FakeCameraVideoTrack]: setDevice\", deviceId);\n  }\n}\n","import type { IMicrophoneAudioTrack } from \"agora-rtc-sdk-ng\";\n\nimport type { FakeLocalAudioTrackProps } from \"./local-audio-track\";\nimport { FakeLocalAudioTrack } from \"./local-audio-track\";\n\nexport interface FakeMicrophoneAudioTrackProps extends FakeLocalAudioTrackProps {}\n\nexport class FakeMicrophoneAudioTrack extends FakeLocalAudioTrack {\n  public static override create(props?: FakeMicrophoneAudioTrackProps): IMicrophoneAudioTrack {\n    return new FakeMicrophoneAudioTrack(props) as unknown as IMicrophoneAudioTrack;\n  }\n  /**\n   * Sets the device for sampling audio.\n   *\n   * > You can call the method either before or after publishing an audio track.\n   *\n   * @param deviceId The ID of the specified device. You can get the `deviceId` by calling AgoraRTC.getMicrophones().\n   */\n  public async setDevice(deviceId: string): Promise<void> {\n    console.log(\"[FakeMicrophoneAudioTrack]: setDevice\", deviceId);\n  }\n}\n","import { createFakeAgoraRTC } from \"./top\";\nimport { FakeCameraVideoTrack, FakeMicrophoneAudioTrack } from \"./tracks\";\n\nexport * from \"./tracks\";\nexport * from \"./eventemitter\";\nexport * from \"./client\";\n\nexport default createFakeAgoraRTC({\n  createMicrophoneAudioTrack: async () => FakeMicrophoneAudioTrack.create(),\n  createCameraVideoTrack: async () => FakeCameraVideoTrack.create(),\n});\n","export type Disposer = () => void;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Fn = (...args: any[]) => any;\nexport type Nullable<T> = T | null | undefined;\nexport type MaybePromise<T> = T | PromiseLike<T>;\nexport type MaybePromiseOrNull<T> = MaybePromise<Nullable<T>>;\n\nexport function invoke<T>(fn: () => T): T | void {\n  try {\n    return fn();\n  } catch (e) {\n    console.error(e);\n  }\n}\n\nexport function joinDisposers(disposers: Disposer[]): Disposer {\n  return () => disposers.forEach(invoke);\n}\n\nexport function interval(fn: Fn, interval: number): Disposer {\n  const id = setInterval(fn, interval);\n  return () => clearInterval(id);\n}\n\nexport function timeout(fn: Fn, ms: number): Disposer {\n  const id = setTimeout(fn, ms);\n  return () => clearTimeout(id);\n}\n\nexport interface AsyncTaskRunner {\n  run: (this: void, task: () => MaybePromise<void | (() => MaybePromise<void>)>) => void;\n  dispose: (this: void) => void;\n}\n\n/**\n * Chain async tasks. During the task running/stopping, if multiple tasks are triggered, only the last one will be executed.\n */\nexport function createAsyncTaskRunner(): AsyncTaskRunner {\n  let isRunning: boolean | undefined;\n  let nextTask: undefined | (() => MaybePromise<void>);\n  let disposer: undefined | void | (() => MaybePromise<void>);\n\n  function runNextTask() {\n    if (nextTask) {\n      const _nextTask = nextTask;\n      nextTask = void 0;\n      _nextTask();\n    }\n  }\n\n  async function disposeEffect() {\n    if (disposer) {\n      const _disposer = disposer;\n      disposer = void 0;\n      try {\n        await _disposer();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n\n  async function runTask(effect: () => MaybePromise<void | (() => MaybePromise<void>)>) {\n    isRunning = true;\n\n    await disposeEffect();\n\n    try {\n      disposer = await effect();\n    } catch (e) {\n      console.error(e);\n    }\n\n    isRunning = false;\n\n    runNextTask();\n  }\n\n  async function stopTask() {\n    isRunning = true;\n\n    await disposeEffect();\n\n    isRunning = false;\n\n    runNextTask();\n  }\n\n  function run(task: () => MaybePromise<void | (() => MaybePromise<void>)>): void {\n    if (isRunning) {\n      nextTask = () => runTask(task);\n    } else {\n      runTask(task);\n    }\n  }\n\n  function dispose(): void {\n    if (isRunning) {\n      nextTask = stopTask;\n    } else {\n      stopTask();\n    }\n  }\n\n  return {\n    run,\n    dispose,\n  };\n}\n","import type { MutableRefObject, Ref, RefObject } from \"react\";\nimport { useCallback, useEffect, useLayoutEffect, useRef, useState } from \"react\";\n\nimport type { AsyncTaskRunner, MaybePromise } from \"../utils\";\nimport { createAsyncTaskRunner } from \"../utils\";\n\nexport const useIsomorphicLayoutEffect =\n  typeof document !== \"undefined\" ? useLayoutEffect : useEffect;\n\nexport function isPromise<T>(value: MaybePromise<T>): value is PromiseLike<T> {\n  return value != null && typeof (value as PromiseLike<T>).then === \"function\";\n}\n\nexport function useForceUpdate() {\n  const [_, forceUpdate] = useState(0);\n  return useCallback(() => forceUpdate(n => (n + 1) | 0), []);\n}\n\nexport function useIsUnmounted(): RefObject<boolean> {\n  const isUnmountRef = useRef(false);\n  useEffect(() => {\n    isUnmountRef.current = false;\n    return () => {\n      isUnmountRef.current = true;\n    };\n  }, []);\n  return isUnmountRef;\n}\n\n/**\n * Leave promise unresolved when the component is unmounted.\n *\n * ```js\n * const sp = useSafePromise()\n * setLoading(true)\n * try {\n *   const result1 = await sp(fetchData1())\n *   const result2 = await sp(fetchData2(result1))\n *   setData(result2)\n * } catch(e) {\n *   setHasError(true)\n * }\n * setLoading(false)\n * ```\n */\nexport function useSafePromise() {\n  const isUnmountRef = useIsUnmounted();\n\n  function safePromise<T, E = unknown>(\n    promise: PromiseLike<T>,\n    onUnmountedError?: (error: E) => void,\n  ) {\n    // the async promise executor is intended\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise<T>(async (resolve, reject) => {\n      try {\n        const result = await promise;\n        if (!isUnmountRef.current) {\n          resolve(result);\n        }\n        // unresolved promises will be garbage collected.\n      } catch (error) {\n        if (!isUnmountRef.current) {\n          reject(error);\n        } else if (onUnmountedError) {\n          onUnmountedError(error as E);\n        } else {\n          if (process.env.NODE_ENV === \"development\") {\n            console.error(\"An error occurs from a promise after a component is unmounted\", error);\n          }\n        }\n      }\n    });\n  }\n\n  return useCallback(safePromise, [isUnmountRef]);\n}\n\nexport function applyRef<T>(ref: Ref<T>, value: T) {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (typeof ref === \"object\" && ref) {\n    (ref as MutableRefObject<T>).current = value;\n  }\n}\n\n/**\n * Sugar to merge forwarded ref and produce a local ref (state).\n *\n * ```jsx\n * const Button = forwardRef((props, ref) => {\n *   const [div, setDiv] = useForwardRef(ref)\n *   // use 'div' here\n *   return <div ref={setDiv} />\n * })\n * ```\n */\nexport function useForwardRef<T>(ref: Ref<T>): [T | null, (value: T | null) => void] {\n  const [current, setCurrent] = useState<T | null>(null);\n  const forwardedRef = useCallback(\n    (value: T | null) => {\n      setCurrent(value);\n      applyRef(ref, value);\n    },\n    [ref, setCurrent],\n  );\n  return [current, forwardedRef];\n}\n\n/**\n * Await a promise or return the value directly.\n */\nexport function useAwaited<T>(promise: MaybePromise<T>): T | undefined {\n  const sp = useSafePromise();\n  const [value, setValue] = useState<T | undefined>();\n\n  useIsomorphicLayoutEffect(() => {\n    if (isPromise(promise)) {\n      sp(promise).then(setValue);\n    } else {\n      setValue(promise);\n    }\n  }, [promise, sp]);\n\n  return value;\n}\n\n/**\n * Accepts a function that contains imperative, possibly asynchronous effect-ful code.\n * During the side-effect running/removing, if multiple effects are triggered, only the last one will be executed.\n */\nexport function useAsyncEffect(\n  effect: () => MaybePromise<void | (() => MaybePromise<void>)>,\n  deps?: ReadonlyArray<unknown>,\n): void {\n  const runnerRef = useRef<AsyncTaskRunner | undefined>();\n  useEffect(() => {\n    const { run, dispose } = (runnerRef.current ||= createAsyncTaskRunner());\n    run(effect);\n    return dispose;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n","import type {\n  ILocalAudioTrack,\n  ILocalVideoTrack,\n  IRemoteAudioTrack,\n  IRemoteVideoTrack,\n  ITrack,\n} from \"agora-rtc-sdk-ng\";\nimport type { PropsWithChildren } from \"react\";\nimport { createContext, useContext, useEffect, useState } from \"react\";\n\nimport { useIsomorphicLayoutEffect } from \"../hooks/tools\";\nimport type { Nullable } from \"../utils\";\nimport { timeout } from \"../utils\";\n\ninterface TrackBoundaryController {\n  onMount: (track: ITrack) => void;\n  onUnmount: (track: ITrack) => void;\n  dispose: () => void;\n}\n\nfunction createTrackBoundaryController(): TrackBoundaryController {\n  const cancelStops = new Map<ITrack, () => void>();\n  const STOP_TIMEOUT = 1500;\n\n  return {\n    onMount: track => {\n      const cancel = cancelStops.get(track);\n      if (cancel) {\n        cancel();\n        cancelStops.delete(track);\n      }\n    },\n    onUnmount: track => {\n      const cancel = cancelStops.get(track);\n      if (cancel) {\n        cancel();\n      }\n      cancelStops.set(\n        track,\n        timeout(() => {\n          if (track.isPlaying) {\n            track.stop();\n          }\n          cancelStops.delete(track);\n        }, STOP_TIMEOUT),\n      );\n    },\n    dispose: () => {\n      for (const [track, cancel] of cancelStops) {\n        if (track.isPlaying) {\n          track.stop();\n        }\n        if (cancel) {\n          cancel();\n        }\n      }\n      cancelStops.clear();\n    },\n  };\n}\n\nconst TrackBoundaryContext = /* @__PURE__ */ createContext<TrackBoundaryController | undefined>(\n  void 0,\n);\n\n/**\n * Delegates track stop of descendant Track Players.\n * This prevents track stops on Track Players unmounts due to re-layout.\n *\n * @example\n * ```jsx\n * <TrackBoundary>\n *   <RemoteUser user={user1} />\n *   <RemoteUser user={user2} />\n * </TrackBoundary>\n * ```\n *\n * @example\n * ```jsx\n * <TrackBoundary>\n *   <RemoteVideoTrack track={track1} />\n *   <RemoteVideoTrack track={track2} />\n * </TrackBoundary>\n * ```\n */\nexport function TrackBoundary({ children }: PropsWithChildren) {\n  const [controller] = useState(createTrackBoundaryController);\n\n  useEffect(() => controller.dispose, [controller]);\n\n  return (\n    <TrackBoundaryContext.Provider value={controller}>{children}</TrackBoundaryContext.Provider>\n  );\n}\n\n/**\n * Stops local or remote video track when the component unmounts.\n * If `<TrackBoundary />` exists in ancestor it will not stop track on unmount but delegates to TrackBoundary.\n */\nexport function useAutoPlayVideoTrack(\n  track: Nullable<IRemoteVideoTrack | ILocalVideoTrack>,\n  play?: boolean,\n  div?: HTMLElement | null,\n) {\n  const controller = useContext(TrackBoundaryContext);\n\n  useEffect(() => {\n    if (track) {\n      if (div && play) {\n        track.play(div);\n      } else {\n        track.stop();\n      }\n\n      if (controller) {\n        controller.onMount(track);\n        return () => controller.onUnmount(track);\n      } else {\n        return () => {\n          if (track.isPlaying) {\n            track.stop();\n          }\n        };\n      }\n    }\n  }, [track, div, play, controller]);\n}\n\n/**\n * Stops local or remote audio track when the component unmounts.\n * If `<TrackBoundary />` exists in ancestor it will not stop track on unmount but delegates to TrackBoundary.\n */\nexport function useAutoPlayAudioTrack(\n  track: Nullable<IRemoteAudioTrack | ILocalAudioTrack>,\n  play?: boolean,\n) {\n  const controller = useContext(TrackBoundaryContext);\n\n  useIsomorphicLayoutEffect(() => {\n    if (track) {\n      if (play) {\n        track.play();\n      } else {\n        track.stop();\n      }\n\n      if (controller) {\n        controller.onMount(track);\n        return () => controller.onUnmount(track);\n      } else {\n        return () => {\n          if (track.isPlaying) {\n            track.stop();\n          }\n        };\n      }\n    }\n  }, [track, play, controller]);\n}\n"],"names":["createFakeAgoraRTC","executor","hideProperties","o","properties","k","FakeAgoraEventEmitter","__publicField","event","listener","listeners","onceListener","args","index","payload","_a","FakeTrack","trackMediaType","trackId","randUuid","props","element","FakeLocalTrack","label","randProductDescription","enabled","muted","trackProps","ipadMp4","FakeLocalVideoTrack","videoURI","config","container","keyboardMp3","FakeLocalAudioTrack","audioURI","volume","deviceId","FakeCameraVideoTrack","FakeMicrophoneAudioTrack","invoke","fn","e","joinDisposers","disposers","interval","id","timeout","ms","createAsyncTaskRunner","isRunning","nextTask","disposer","runNextTask","_nextTask","disposeEffect","_disposer","runTask","effect","stopTask","run","task","dispose","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","isPromise","value","useIsUnmounted","isUnmountRef","useRef","useSafePromise","safePromise","promise","onUnmountedError","resolve","reject","result","error","useCallback","useAwaited","sp","setValue","useState","createTrackBoundaryController","cancelStops","STOP_TIMEOUT","track","cancel","TrackBoundaryContext","createContext","TrackBoundary","children","controller","useAutoPlayVideoTrack","play","div","useContext","useAutoPlayAudioTrack"],"mappings":"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"}