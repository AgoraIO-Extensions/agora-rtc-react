{"version":3,"file":"useRTCClient-c750e90a.js","sources":["../../../../node_modules/.pnpm/side-effect-manager@1.2.2/node_modules/side-effect-manager/dist/index.mjs","../../../../node_modules/.pnpm/github.com+AgoraIO-Extensions+agora-rtc-sdk-ng-fake@0a75c0c8fe4748e6063e188dbeee5ead2e698735_jfezfsem5m4j3qpgind2x3ovjq/node_modules/@agoraio-extensions/agora-rtc-sdk-ng-fake/src/client.ts","../../src/components/UserCover.tsx","../../src/hooks/useRTCClient.tsx"],"sourcesContent":["// src/gen-uid.ts\nvar SOUP = \"!#%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nvar SOUP_LEN = 87;\nvar ID_LEN = 20;\nvar reusedIdCarrier = [];\nvar genUID = () => {\n  for (let i = 0; i < ID_LEN; i++) {\n    reusedIdCarrier[i] = SOUP.charAt(Math.random() * SOUP_LEN);\n  }\n  return reusedIdCarrier.join(\"\");\n};\n\n// src/utils.ts\nfunction invoke(fn) {\n  try {\n    return fn();\n  } catch (e) {\n    console.error(e);\n  }\n}\n\n// src/side-effect-manager.ts\nvar SideEffectManager = class {\n  constructor() {\n    /**\n     * @alias addDisposer\n     * Add a disposer directly.\n     * @param disposer a disposer or a list of disposers\n     * @param disposerID Optional id for the disposer\n     * @returns disposerID\n     */\n    this.push = this.addDisposer;\n    /**\n     * All disposers. Use this only when you know what you are doing.\n     */\n    this.disposers = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Add a disposer directly.\n   * @param disposer a disposer or a list of disposers\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  addDisposer(disposer, disposerID = this.genUID()) {\n    this.flush(disposerID);\n    this.disposers.set(\n      disposerID,\n      Array.isArray(disposer) ? joinDisposers(disposer) : disposer\n    );\n    return disposerID;\n  }\n  /**\n   * Add a side effect.\n   * @param executor Executes side effect. Return a disposer or a list of disposers. Returns null or false to ignore.\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  add(executor, disposerID = this.genUID()) {\n    const disposers = executor();\n    return disposers ? this.addDisposer(disposers, disposerID) : disposerID;\n  }\n  addEventListener(el, type, listener, options, disposerID = this.genUID()) {\n    el.addEventListener(type, listener, options);\n    this.addDisposer(\n      () => el.removeEventListener(type, listener, options),\n      disposerID\n    );\n    return disposerID;\n  }\n  /**\n   * Sugar for setTimeout.\n   * @param handler\n   * @param timeout\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  setTimeout(handler, timeout, disposerID = this.genUID()) {\n    const ticket = window.setTimeout(() => {\n      this.remove(disposerID);\n      handler();\n    }, timeout);\n    return this.addDisposer(() => window.clearTimeout(ticket), disposerID);\n  }\n  /**\n   * Sugar for setInterval.\n   * @param handler\n   * @param timeout\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  setInterval(handler, timeout, disposerID = this.genUID()) {\n    const ticket = window.setInterval(handler, timeout);\n    return this.addDisposer(() => window.clearInterval(ticket), disposerID);\n  }\n  /**\n   * Remove but not run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  remove(disposerID) {\n    const disposer = this.disposers.get(disposerID);\n    this.disposers.delete(disposerID);\n    return disposer;\n  }\n  /**\n   * Remove and run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  flush(disposerID) {\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      disposer();\n    }\n  }\n  /**\n   * Remove and run all of the disposers.\n   */\n  flushAll() {\n    this.disposers.forEach(invoke);\n    this.disposers.clear();\n  }\n  genUID() {\n    let uid;\n    do {\n      uid = genUID();\n    } while (this.disposers.has(uid));\n    return uid;\n  }\n};\nfunction joinDisposers(disposers) {\n  return () => disposers.forEach(invoke);\n}\n\n// src/async-side-effect-manager.ts\nvar AsyncSideEffectManager = class {\n  constructor() {\n    /**\n     * @alias addDisposer\n     * Add a disposer directly.\n     * @param disposer a disposer\n     * @param disposerID Optional id for the disposer\n     * @returns disposerID\n     */\n    this.push = this.addDisposer;\n    /**\n     * @returns a Promise resolved when current tasks are finished.\n     */\n    this.finished = Promise.resolve();\n    /**\n     * All disposers. Use this only when you know what you are doing.\n     */\n    this.disposers = /* @__PURE__ */ new Map();\n    this._n = /* @__PURE__ */ new Map();\n    this._i = /* @__PURE__ */ new Set();\n  }\n  /**\n   * Add a side effect.\n   * @param executor Execute side effect. Return a disposer or a disposer array. Return null or false to ignore.\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  add(executor, disposerID = this.genUID()) {\n    if (this._i.has(disposerID)) {\n      this._n.set(disposerID, () => this._a(executor, disposerID));\n    } else {\n      this._a(executor, disposerID);\n    }\n    return disposerID;\n  }\n  async _a(executor, disposerID) {\n    this._s(disposerID);\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      try {\n        await disposer();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    try {\n      const disposers = await executor();\n      if (disposers) {\n        this.disposers.set(\n          disposerID,\n          Array.isArray(disposers) ? joinAsyncDisposers(disposers) : disposers\n        );\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    this._e(disposerID);\n    const task = this._n.get(disposerID);\n    if (task) {\n      this._n.delete(disposerID);\n      task();\n    }\n  }\n  /**\n   * Add a disposer directly.\n   * @param disposer a disposer\n   * @param disposerID Optional id for the disposer\n   * @returns disposerID\n   */\n  addDisposer(disposer, disposerID = this.genUID()) {\n    return this.add(() => disposer, disposerID);\n  }\n  /**\n   * Remove but not run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  remove(disposerID) {\n    const disposer = this.disposers.get(disposerID);\n    this.disposers.delete(disposerID);\n    return disposer;\n  }\n  /**\n   * Remove and run the disposer. Do nothing if not found.\n   * @param disposerID\n   */\n  flush(disposerID) {\n    if (this._i.has(disposerID)) {\n      this._n.set(disposerID, () => this._f(disposerID));\n    } else {\n      this._f(disposerID);\n    }\n  }\n  async _f(disposerID) {\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      this._s(disposerID);\n      try {\n        await disposer();\n      } catch (e) {\n        console.error(e);\n      }\n      this._e(disposerID);\n    }\n    const task = this._n.get(disposerID);\n    if (task) {\n      this._n.delete(disposerID);\n      task();\n    }\n  }\n  /**\n   * Remove and run all of the disposers.\n   */\n  flushAll() {\n    this.disposers.forEach((_, disposerID) => this.flush(disposerID));\n  }\n  genUID() {\n    let uid;\n    do {\n      uid = genUID();\n    } while (this.disposers.has(uid));\n    return uid;\n  }\n  _s(disposerID) {\n    this._i.add(disposerID);\n    if (!this._r) {\n      this.finished = new Promise((resolve) => {\n        this._r = resolve;\n      });\n    }\n  }\n  _e(disposerID) {\n    this._i.delete(disposerID);\n    if (this._r && this._i.size <= 0 && this._n.size <= 0) {\n      this._r();\n      this._r = void 0;\n    }\n  }\n};\nfunction joinAsyncDisposers(disposers) {\n  return () => Promise.all(disposers.map(invoke));\n}\n\n// src/disposable.ts\nvar Disposable = class {\n  constructor() {\n    /**\n     * @alias addDisposer\n     * Add a disposer directly.\n     * @param disposer a disposer or a list of disposers\n     */\n    this.push = this.addDisposer;\n    /**\n     * All disposers. Use this only when you know what you are doing.\n     */\n    this.disposers = /* @__PURE__ */ new Set();\n  }\n  /**\n   * Add a disposer directly.\n   * @param disposers a disposer or a list of disposers\n   */\n  addDisposer(disposers) {\n    if (Array.isArray(disposers)) {\n      disposers.forEach((disposer) => {\n        this.disposers.add(disposer);\n      });\n    } else {\n      this.disposers.add(disposers);\n    }\n  }\n  /**\n   * Add a side effect.\n   * @param executor Executes side effect. Return a disposer or a list of disposers. Returns null or false to ignore.\n   */\n  add(executor) {\n    const disposers = executor();\n    if (disposers) {\n      this.push(disposers);\n    }\n  }\n  addEventListener(el, type, listener, options) {\n    el.addEventListener(type, listener, options);\n    const disposer = () => el.removeEventListener(type, listener, options);\n    this.push(disposer);\n    return disposer;\n  }\n  /**\n   * Sugar for setTimeout.\n   * @param handler\n   * @param timeout\n   * @returns ticket\n   */\n  setTimeout(handler, timeout) {\n    const ticket = window.setTimeout(() => {\n      this.remove(disposer);\n      handler();\n    }, timeout);\n    const disposer = () => window.clearTimeout(ticket);\n    this.push(disposer);\n    return disposer;\n  }\n  /**\n   * Sugar for setInterval.\n   * @param handler\n   * @param timeout\n   * @returns ticket\n   */\n  setInterval(handler, timeout) {\n    const ticket = setInterval(handler, timeout);\n    const disposer = () => clearInterval(ticket);\n    this.push(disposer);\n    return disposer;\n  }\n  /**\n   * Remove but not run the disposer. Do nothing if not found.\n   * @param disposer\n   */\n  remove(disposer) {\n    this.disposers.delete(disposer);\n  }\n  /**\n   * Remove and run the disposer. Do nothing if not found.\n   * @param disposer\n   */\n  flush(disposer) {\n    this.remove(disposer);\n    disposer();\n  }\n  /**\n   * Remove and run all of the disposers.\n   */\n  flushAll() {\n    this.disposers.forEach(invoke);\n    this.disposers.clear();\n  }\n};\n\nexport { AsyncSideEffectManager, Disposable, SideEffectManager, genUID, joinAsyncDisposers, joinDisposers };\n","import { randNumber, randUuid } from \"@ngneat/falso\";\nimport type {\n  IAgoraRTCClient,\n  IAgoraRTCRemoteUser,\n  IRemoteAudioTrack,\n  IRemoteTrack,\n  IRemoteVideoTrack,\n  UID,\n} from \"agora-rtc-sdk-ng\";\nimport { SideEffectManager } from \"side-effect-manager\";\n\nimport { FakeAgoraEventEmitter } from \"./eventemitter\";\nimport { FakeRemoteAudioTrack, FakeRemoteVideoTrack } from \"./tracks\";\nimport { hideProperties } from \"./utils\";\n\nexport class FakeRTCClient extends FakeAgoraEventEmitter {\n  remoteUsers: IAgoraRTCRemoteUser[] = [];\n\n  public static create(\n    executor?: Partial<IAgoraRTCClient> | ((client: FakeRTCClient) => Partial<IAgoraRTCClient>),\n  ): IAgoraRTCClient {\n    const client = new FakeRTCClient();\n    const partialClient = typeof executor === \"function\" ? executor(client) : executor;\n    return Object.assign(client, partialClient) as unknown as IAgoraRTCClient;\n  }\n\n  private _sideEffect = new SideEffectManager();\n\n  public constructor() {\n    super();\n    hideProperties(this, \"_disposable\");\n  }\n\n  /**\n   * Subscribes to the audio and/or video tracks of a remote user.\n   *\n   * ```javascript\n   * await client.subscribe(user，\"audio\");\n   * user.audioTrack.play();\n   * ```\n   * @param user The remote user.\n   * @param mediaType The media type of the tracks to subscribe to.\n   * - `\"video\"`: Subscribe to the video track only.\n   * - `\"audio\"`: Subscribe to the audio track only.\n   *\n   * @returns When the subscription succeeds, the SDK adds the subscribed tracks to [user.audioTrack]{@link IAgoraRTCRemoteUser.audioTrack} and [user.videoTrack]{@link IAgoraRTCRemoteUser.videoTrack}. You can go on to call [audioTrack.play]{@link IRemoteAudioTrack.play} or [videoTrack.play]{@link IRemoteVideoTrack.play} to play the tracks.\n   * > The `Promise` object throws the `TRACK_IS_NOT_PUBLISHED` error if the specified tracks do not exist.\n   * @category Agora Core\n   */\n  public subscribe(user: IAgoraRTCRemoteUser, mediaType: \"video\"): Promise<IRemoteVideoTrack>;\n  /**\n   * Subscribes to the audio and/or video tracks of a remote user.\n   *\n   * ```javascript\n   * await client.subscribe(user，\"audio\");\n   * user.audioTrack.play();\n   * ```\n   * @param user The remote user.\n   * @param mediaType The media type of the tracks to subscribe to.\n   * - `\"video\"`: Subscribe to the video track only.\n   * - `\"audio\"`: Subscribe to the audio track only.\n   *\n   * @returns When the subscription succeeds, the SDK adds the subscribed tracks to [user.audioTrack]{@link IAgoraRTCRemoteUser.audioTrack} and [user.videoTrack]{@link IAgoraRTCRemoteUser.videoTrack}. You can go on to call [audioTrack.play]{@link IRemoteAudioTrack.play} or [videoTrack.play]{@link IRemoteVideoTrack.play} to play the tracks.\n   * > The `Promise` object throws the `TRACK_IS_NOT_PUBLISHED` error if the specified tracks do not exist.\n   * @category Agora Core\n   */\n  public subscribe(user: IAgoraRTCRemoteUser, mediaType: \"audio\"): Promise<IRemoteAudioTrack>;\n  /**\n   * Subscribes to the audio and/or video tracks of a remote user.\n   *\n   * ```javascript\n   * await client.subscribe(user，\"audio\");\n   * user.audioTrack.play();\n   * ```\n   * @param user The remote user.\n   * @param mediaType The media type of the tracks to subscribe to.\n   * - `\"video\"`: Subscribe to the video track only.\n   * - `\"audio\"`: Subscribe to the audio track only.\n   *\n   * @returns When the subscription succeeds, the SDK adds the subscribed tracks to [user.audioTrack]{@link IAgoraRTCRemoteUser.audioTrack} and [user.videoTrack]{@link IAgoraRTCRemoteUser.videoTrack}. You can go on to call [audioTrack.play]{@link IRemoteAudioTrack.play} or [videoTrack.play]{@link IRemoteVideoTrack.play} to play the tracks.\n   * > The `Promise` object throws the `TRACK_IS_NOT_PUBLISHED` error if the specified tracks do not exist.\n   * @category Agora Core\n   */\n  public subscribe(user: IAgoraRTCRemoteUser, mediaType: \"video\" | \"audio\"): Promise<IRemoteTrack>;\n  public subscribe(user: IAgoraRTCRemoteUser, mediaType: \"video\" | \"audio\"): Promise<IRemoteTrack> {\n    if (mediaType === \"audio\") {\n      if (!user.audioTrack) {\n        const audioTrack = FakeRemoteAudioTrack.create();\n        user.audioTrack = audioTrack;\n        this._sideEffect.setInterval(\n          () => {\n            audioTrack.setVolume(randNumber({ min: 0, max: 100 }));\n          },\n          2000,\n          String(user.uid),\n        );\n      }\n      return Promise.resolve(user.audioTrack);\n    } else {\n      if (!user.videoTrack) {\n        const videoTrack = FakeRemoteVideoTrack.create();\n        user.videoTrack = videoTrack;\n      }\n      return Promise.resolve(user.videoTrack);\n    }\n  }\n\n  async unsubscribe(user: IAgoraRTCRemoteUser, mediaType?: \"video\" | \"audio\" | undefined) {\n    if (!mediaType || mediaType === \"audio\") {\n      if (user.audioTrack) {\n        user.audioTrack.stop();\n        user.audioTrack = undefined;\n        this._sideEffect.flush(String(user.uid));\n      }\n    }\n\n    if (!mediaType || mediaType === \"video\") {\n      if (user.videoTrack) {\n        user.videoTrack.stop();\n        user.videoTrack = undefined;\n      }\n    }\n  }\n\n  public massUnsubscribe(users: IAgoraRTCRemoteUser[], mediaType?: \"video\" | \"audio\" | undefined) {\n    users.forEach(user => {\n      this.unsubscribe(user, mediaType);\n    });\n  }\n\n  public join(): Promise<UID> {\n    return Promise.resolve(randUuid());\n  }\n\n  public leave(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n","import type { CSSProperties, ReactNode } from \"react\";\n\nimport { FloatBoxStyle } from \"../assets/styles\";\n\nconst CoverBlurStyle: CSSProperties = {\n  width: \"100%\",\n  height: \"100%\",\n  background: \"#1a1e21 center/cover no-repeat\",\n  filter: \"blur(16px) brightness(0.4)\",\n};\n\nconst CoverImgStyle: CSSProperties = {\n  position: \"absolute\",\n  top: \"50%\",\n  left: \"50%\",\n  maxWidth: \"50%\",\n  maxHeight: \"50%\",\n  aspectRatio: \"1\",\n  transform: \"translate(-50%, -50%)\",\n  borderRadius: \"50%\",\n  overflow: \"hidden\",\n  objectFit: \"cover\",\n};\n\nexport interface UserCoverProps {\n  /**\n   * Cover image url or a custom render function.\n   */\n  cover: string | (() => ReactNode);\n}\n\n/**\n * User Cover image with blur background\n */\nexport function UserCover({ cover }: UserCoverProps) {\n  return (\n    <div style={FloatBoxStyle}>\n      {typeof cover === \"string\" ? (\n        <>\n          <div style={{ ...CoverBlurStyle, backgroundImage: `url(${cover})` }} />\n          <img src={cover} style={CoverImgStyle} />\n        </>\n      ) : (\n        cover()\n      )}\n    </div>\n  );\n}\n","import type { IAgoraRTCClient } from \"agora-rtc-sdk-ng\";\nimport { createContext, useContext } from \"react\";\n\nimport type { AgoraRTCProviderProps } from \"./types\";\n\nconst AgoraRTCContext = /* @__PURE__ */ createContext<IAgoraRTCClient | null>(null);\n\nexport function AgoraRTCProvider({ client, children }: AgoraRTCProviderProps) {\n  return <AgoraRTCContext.Provider value={client}>{children}</AgoraRTCContext.Provider>;\n}\n/**\n * @ignore\n */\nfunction useOptionalRTCClient(client?: IAgoraRTCClient | null): IAgoraRTCClient | null {\n  const clientFromContext = useContext(AgoraRTCContext);\n  return client || clientFromContext;\n}\n\n/**\n * Returns the IAgoraRTCClient object.\n *\n * @param client - If provided, the passed `IAgoraRTCClient` object is returned. If not provided, the `IAgoraRTCClient` object obtained from the [parent component's context](https://api-ref.agora.io/en/video-sdk/reactjs/2.x/functions/AgoraRTCProvider.html) is returned.\n * @example\n * ```jsx\n * import { useRTCClient } from \"agora-rtc-react\";\n *\n * function App() {\n *   const client = useRTCClient();\n *\n *   return <></>;\n * }\n * ```\n */\nexport function useRTCClient(client?: IAgoraRTCClient | null): IAgoraRTCClient {\n  const resolvedClient = useOptionalRTCClient(client);\n\n  if (!resolvedClient) {\n    throw new Error(\n      \"Agora RTC client not found. Should be wrapped in <AgoraRTCProvider value={client} />\",\n    );\n  }\n\n  return resolvedClient;\n}\n"],"names":["SOUP","SOUP_LEN","ID_LEN","reusedIdCarrier","genUID","i","invoke","fn","SideEffectManager","disposer","disposerID","joinDisposers","executor","disposers","el","type","listener","options","handler","timeout","ticket","uid","FakeRTCClient","FakeAgoraEventEmitter","hideProperties","client","partialClient","user","mediaType","audioTrack","FakeRemoteAudioTrack","randNumber","videoTrack","FakeRemoteVideoTrack","users","randUuid","CoverBlurStyle","CoverImgStyle","UserCover","cover","FloatBoxStyle","jsxs","Fragment","jsx","AgoraRTCContext","AgoraRTCProvider","children","useOptionalRTCClient","clientFromContext","useContext","useRTCClient","resolvedClient"],"mappings":"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","x_google_ignoreList":[0,1]}